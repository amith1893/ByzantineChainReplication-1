import time
import random
import string
import hashlib


#receive request from client
#check if config is null or not
#if it is null
#call the configuration object
class Olympus(process):
    def setup():
        pass
  
    def run():
        pass


class BankAccount:
    def __init__(self, name, account_id):
        self.name = name
        self.account_id = account_id
        self.balance = 0
        self.num_deposits = 0
        self.num_withdrawals = 0

    def deposit(self, amount):    
        self.num_deposits += 1
        self.balance += amount

    def withdraw(self, amount):
        self.num_withdrawals += 1
        self.balance -= amount
   
    def getBalance(self):
        return self.balance

    def getAccountId(self):
        return self.account_id

    def getAccountName(self):
        return self.name


class Replica(process):
    def setup(neighbours, client, name, private_key, public_key):
        self.predecessor = neighbours[0]
        self.successor = neighbours[1]
        self.name = name
        self.history = {}
        self.client = client
        self.terminate = 0
        self.unverified = []
        self.input_set = []
        self.output_set = []
        self.private_key = private_key
        self.public_key = public_key
        self.slot = 0
        self.bank_accounts = {}

    def run():
        await(self.terminate == -1)
    
    def receive(msg=('rshuttle', action, r, id), from_=sender):
        if self.name == 'replica':
            self.history[action] = [r["order_proof"], r["result_proof"], r["result"]]
        elif self.name == 'head':
            self.history[action] = [r["order_proof"], r["result_proof"], r["result"]]
            
    def receive(msg=('fshuttle', action, l, id), from_=sender):
        if self.name == 'replica':
            res = self.evaluate(action)
            oproof = [self.slot, action, self.id]
            rproof = [res, action, hashlib.sha224(res.encode('utf-8')).hexdigest(), self.id]
            l["order_proof"].append(oproof)
            l["result_proof"].append(rproof)
            self.slot += 1
            send(('fshuttle', action, l, self.id), to=self.successor)
            await(some(received(('rshuttle', action, r, id)), has = id == self.successor))
            send(('rshuttle', action, r, self.id), to=self.predecessor)
        elif self.name == 'tail':
            res = self.evaluate(action)
            oproof = [self.slot, action, self.id]
            rproof = [res, action, hashlib.sha224(res.encode('utf-8')).hexdigest(), self.id]
            l["order_proof"].append(oproof)
            l["result_proof"].append(rproof)
            self.slot += 1
            send(('result', l["result_proof"], res, self.id), to=self.client)
            r = {"order_proof": l["order_proof"], "result_proof": l["result_proof"], "action":action, "result": res}
            self.history[action] = [l["order_proof"], l["result_proof"], res]
            output("History ", self.history)
            output("Forward Shuttle till tail ", l)
            send(('rshuttle', action, r, self.id), to=self.predecessor)
         
    def receive(msg=('newm', action), from_=sender):
        if self.name == 'head':
            res = self.evaluate(action)
            l = {"action": action, "order_proof":[], "result_proof":[]}
            oproof = [self.slot, action, self.id]
            rproof = [res, action, hashlib.sha224(res.encode('utf-8')).hexdigest(), self.id]
            l["order_proof"].append(oproof)
            l["result_proof"].append(rproof)
            self.slot += 1
            send(('fshuttle', action, l, self.id), to=self.successor)
            await(some(received(('rshuttle', action, r, id)), has = id == self.successor))
            output("Received Result Proof from the successor ", self.successor, " Will not send the result proof to the client as the tail has already sent", self.client)
            output("Result Proof as received by the head by it's successor   ", r)

    def evaluate(action):
        op = action.split()
        action = op[0]
        param = op[1]
        account_id = 0
        if op[0] == 'create':
            account_id = op[2]
            b = BankAccount(op[1], account_id)
            if account_id not in self.bank_accounts.keys():
                self.bank_accounts[account_id] = b
                res = "Bank Account " + account_id + " created"
                return res
            else:
                return "Already present. Cannot be created"
        elif op[0] == 'deposit':
            self.bank_accounts[param].deposit(float(op[2]))
            res = str(op[2]) + " deposited in " + op[1]
            return res
        elif op[0] == 'withdraw':
            val = self.bank_accounts[param].getBalance() - float(op[2])
            res = ""
            if val < 0:
                res = "Withdrawal not possible"
            else:
                self.bank_accounts[param].withdraw(float(op[2]))
                res = "Withdrawal of " + op[2] + " from " + op[1] + " successful"
            return res
        elif op[0] == 'balance':
            bal = self.bank_accounts[param].getBalance()
            res = "Balance of account " + param + " is " + bal
            return res    
   
class Client(process):
    def setup(servers):
	    pass

    def run():
        res=0
        output("sending command from client to the head of the replicas")
        output(self.servers[0])
        send(('newm', 'create amith 250'), to=self.servers[0])
        await(some(received(('result', res_proof, res, p)), has = p == servers[len(servers)-1]))
        output("Result received from the tail ", res)
        #send(('Done',), to=parent())

    def receive(msg=('result', res_proof, res, p), from_=sender):
        output("Result Proof received from the tail ", res_proof)

def generate_keys():
    private_key = ''.join(random.choices(string.ascii_letters + string.digits, k=5)) 
    public_key = ''.join(random.choices(string.ascii_letters + string.digits, k=5)) 
    return private_key, public_key

def main():
    num_replicas = 7
    num_clients = 1
    servers = new(Replica, num=num_replicas)
    clients = new(Client, num=num_clients)
    
    for s in range(0, len(servers)):
        private_key, public_key = generate_keys()
        if s == 0:
            setup(list(servers)[s], (("null", list(servers)[1]), list(clients)[0], "head", private_key, public_key))
        elif s == len(servers)-1:
            setup(list(servers)[s], ((list(servers)[s-1], "null"), list(clients)[0], "tail", private_key, public_key))
        else:
            setup(list(servers)[s], ((list(servers)[s-1], list(servers)[s+1]), list(clients)[0], "replica", private_key, public_key))


    setup(clients, (list(servers),))
    start(servers)
    output("Servers started !!")
    output(servers)
    start(clients)
    output("Clients started !!")
    await(received(('Done',)))
    end(servers)
